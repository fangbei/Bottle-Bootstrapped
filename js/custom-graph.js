function GraphDataSet( id )
{
    /***
    Class Represents a graph data set.
    ***/

    var self = this;

    /*** Values ***/
    self.data = [];
    self.id = id;
    self.color = "#000000";

    /*** Methods ***/
    self.loadData = load_data;

    function load_data( dataset, format ){

        switch( format ){
            case "Y":
                $.each( dataset, function( ix, val){
                    self.data.push( [ix, val] );
                });
                break;
            case "X":
                $.each( dataset, function( ix, val){
                    self.data.push( [val, ix] );
                });
                break;
            case "XY":
                self.data = dataset.slice(0); //Clone array
                break;
            case "YX":
                $.each( dataset, function( ix, val){
                    self.data.push( [val[1], val[0]] );
                });
                break;
        }

    }
}

function Graph()
{
    /***
    Class Represents a graph. Plots with flotr2.
    ***/

    var self = this;

    /*** Values ***/
    self.container = document.getElementById("plot1");
    self.visible = ko.observable( true );
    self.datasets = ko.observableArray( [] );

    /*** Methods ***/
    self.addDataSet = add_data_set;
    self.drawGraph = draw_graph;
    self.getDataSetsArray = get_datasets_array;

    function add_data_set( id, dataset, format ){
        /*** Add a GraphDataSet ***/
        
        var graphdataset = new GraphDataSet( id );
        graphdataset.loadData( dataset, format );

        self.datasets.push( graphdataset );
    }

    function get_datasets_array(){
        /*** Returns an array of the data in the GraphDataSets ***/

        var data = [];

        $.each( self.datasets(), function(ix, graphDataSet ){
            data.push( graphDataSet.data );
        });

        return data;
    }

    self.datasets.subscribe( function ( graphDataSet ) {
        /*** Redraw graph if new GraphDataSet is added or removed ***/
        self.drawGraph();
    }, self);

    function draw_graph(){
        /*** Draw a flotr2 plot ***/

        if( self.datasets().length === 0 ){
            return false;
        }
        //var d1 = [[0, 0], [1, 20], [5, 50], [10, 100]];// First data series
        //var d2 = [[0, 0], [1, 10], [2, 30], [10, 100]];// Second data series

        var thegraph;

        self.container.innerHTML = '';

        // Draw Graph
        thegraph = Flotr.draw( self.container , self.getDataSetsArray() , {
            xaxis: {
            ticks: null,           // => format: either [1, 3] or [[1, 'a'], 3]
            minorTicks: null,      // => format: either [1, 3] or [[1, 'a'], 3]
            showLabels: true,      // => setting to true will show the axis ticks labels, hide otherwise
            showMinorLabels: false,// => true to show the axis minor ticks labels, false to hide
            labelsAngle: 0,        // => labels' angle, in degrees
            title: 'Cluster Size',           // => axis title
            titleAngle: 0,         // => axis title's angle, in degrees
            noTicks: 10,            // => number of ticks for automagically generated ticks
            minorTickFreq: 5,     // => number of minor ticks between major ticks for autogenerated ticks
            tickFormatter: Flotr.defaultTickFormatter, // => fn: number, Object -> string
            tickDecimals: null,    // => no. of decimals, null means auto
            min: null,             // => min. value to show, null means set automatically
            max: null,             // => max. value to show, null means set automatically
            autoscale: false,      // => Turns autoscaling on with true
            autoscaleMargin: 0,    // => margin in % to add if auto-setting min/max
            color: null,           // => color of the ticks
            mode: 'normal',        // => can be 'time' or 'normal'
            timeFormat: null,
            timeMode:'UTC',        // => For UTC time ('local' for local time).
            timeUnit:'millisecond',// => Unit for time (millisecond, second, minute, hour, day,Â month, year)
            scaling: 'linear',     // => Scaling, can be 'linear' or 'logarithmic'
            base: Math.E,
            titleAlign: 'center',
            margin: true           // => Turn off margins with false
            },
            yaxis: {
            ticks: null,           // => format: either [1, 3] or [[1, 'a'], 3]
            minorTicks: null,      // => format: either [1, 3] or [[1, 'a'], 3]
            showLabels: true,      // => setting to true will show the axis ticks labels, hide otherwise
            showMinorLabels: false,// => true to show the axis minor ticks labels, false to hide
            labelsAngle: 0,        // => labels' angle, in degrees
            title: 'Cluster Score',           // => axis title
            titleAngle: 90,        // => axis title's angle, in degrees
            noTicks: 20,            // => number of ticks for automagically generated ticks
            minorTickFreq: 2,      // => number of minor ticks between major ticks for autogenerated ticks
            tickFormatter: Flotr.defaultTickFormatter, // => fn: number, Object -> string
            tickDecimals: null,    // => no. of decimals, null means auto
            min: null,             // => min. value to show, null means set automatically
            max: null,             // => max. value to show, null means set automatically
            autoscale: false,      // => Turns autoscaling on with true
            autoscaleMargin: 0,    // => margin in % to add if auto-setting min/max
            color: null,           // => The color of the ticks
            scaling: 'linear',     // => Scaling, can be 'linear' or 'logarithmic'
            base: Math.E,
            titleAlign: 'center',
            margin: true          // => Turn off margins with false
            },
            y2axis: {
            titleAngle: 270
            },
            grid: {
            color: '#545454',      // => primary color used for outline and labels
            backgroundColor: null, // => null for transparent, else color
            backgroundImage: null, // => background image. String or object with src, left and top
            watermarkAlpha: 0.4,   // => 
            tickColor: '#DDDDDD',  // => color used for the ticks
            labelMargin: 3,        // => margin in pixels
            verticalLines: true,   // => whether to show gridlines in vertical direction
            minorVerticalLines: true, // => whether to show gridlines for minor ticks in vertical dir.
            horizontalLines: true, // => whether to show gridlines in horizontal direction
            minorHorizontalLines: true, // => whether to show gridlines for minor ticks in horizontal dir.
            outlineWidth: 1,       // => width of the grid outline/border in pixels
            outline : 'nsew',      // => walls of the outline to display
            circular: false        // => if set to true, the grid will be circular, must be used when radars are drawn
            },
            mouse: {
            track: false,          // => true to track the mouse, no tracking otherwise
            trackAll: false,
            position: 'se',        // => position of the value box (default south-east)
            relative: false,       // => next to the mouse cursor
            trackFormatter: Flotr.defaultTrackFormatter, // => formats the values in the value box
            margin: 5,             // => margin in pixels of the valuebox
            lineColor: '#FF3F19',  // => line color of points that are drawn when mouse comes near a value of a series
            trackDecimals: 1,      // => decimals for the track values
            sensibility: 2,        // => the lower this number, the more precise you have to aim to show a value
            trackY: true,          // => whether or not to track the mouse in the y axis
            radius: 3,             // => radius of the track point
            fillColor: null,       // => color to fill our select bar with only applies to bar and similar graphs (only bars for now)
            fillOpacity: 0.4       // => opacity of the fill color, set to 1 for a solid fill, 0 hides the fill 
            },
            HtmlText : false
        });

        $.each( self.datasets(), function(ix, graphDataSet){
            graphDataSet.color = thegraph.series[ ix ].color;
        });

    }

    /*
    self.addDataSet( "test1: custom-graph.js", [1,2,3,4,5,6,7,8,9], 'Y' );
    self.addDataSet( "test2: custom-graph.js", [1,2,3,4,5,6,7,8,9], 'X' );

    self.drawGraph( self.container );
    */

}